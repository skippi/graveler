package graveler.forge

import org.apache.logging.log4j.LogManager

import java.lang.reflect.Field
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method

import net.minecraftforge.fml.common._
import net.minecraftforge.fml.relauncher.Side

class ScalaLanguageAdapter extends ILanguageAdapter {
  private final val Log = LogManager.getLogger("ScorgeScalaAdapter")

  @throws[Exception]
  override def getNewInstance(
      container: FMLModContainer,
      scalaObjectClass: Class[_],
      classLoader: ClassLoader,
      factoryMarkedAnnotation: Method
  ): AnyRef = {
    val sObjectClass =
      Class.forName(s"${scalaObjectClass.getName}$$", true, classLoader)
    sObjectClass.getField("MODULE$").get(null)
  }

  override def supportsStatics: Boolean = false

  @throws[IllegalArgumentException]
  @throws[IllegalAccessException]
  @throws[NoSuchFieldException]
  @throws[SecurityException]
  override def setProxy(
      target: Field,
      proxyTarget: Class[_],
      proxy: AnyRef
  ): Unit = {
    var trueProxyTarget = proxyTarget

    try {
      // Get the actual singleton class. The two variants are from
      // whether the @SidedProxy is declared in a the class block
      // of the object directly, or in the object block, i.e.
      // whether it's:
      // class ModName {
      //   @SidedProxy ...
      // }
      // object ModName extends ModName {}
      // which leads to us getting the outer class, or
      // object ModName {
      //   @SidedProxy ...
      // }
      // which leads to us getting the inner class.
      if (!proxyTarget.getName.endsWith("$")) {
        // Get internal class generated by Scala.
        trueProxyTarget = Class.forName(
          s"${proxyTarget.getName}$$",
          true,
          proxyTarget.getClassLoader
        )
      }
    } catch {
      case e: ClassNotFoundException =>
        // Not a singleton, look for @Instance field as a fallback.
        Log.info(
          "An error occurred trying to load a proxy into {}.{}. Did you declare your mod as 'class' instead of 'object'?",
          proxyTarget.getSimpleName,
          target.getName,
          e
        )
        return
    }

    // Get the instance via the MODULE$ field which is
    // automatically generated by the Scala compiler for
    // singletons.
    val targetInstance = trueProxyTarget.getField("MODULE$").get(null)

    try {
      // Find setter function. We do it this way because we can't
      // necessarily use proxyTarget.getMethod(proxy.getClass), as
      // it might be a subclass and not the exact parameter type.
      // All fields are private in Scala, wrapped by a getter and
      // setter named <fieldname> and <fieldname>_$eq. To those
      // familiar with scala.reflect.BeanProperty: these will always
      // be there, set<Fieldname> and get<Fieldname> will always
      // only be generated *additionally*.
      val setterName = target.getName + "_$eq"
      for (setter <- trueProxyTarget.getMethods) {
        val setterParameters: Array[Class[_]] = setter.getParameterTypes
        if (setterName.equals(setter.getName) &&
            // Some more validation.
            setterParameters.length == 1 &&
            setterParameters(0).isAssignableFrom(proxy.getClass)) {
          // Here goes nothing...
          setter.invoke(targetInstance, proxy)
          return
        }
      }
    } catch {
      case e: InvocationTargetException =>
        Log.error(
          "An error occurred trying to load a proxy into {}.{}",
          target.getName,
          e
        )
        throw new LoaderException(e)
    }

    // If we come here we could not find a setter for this proxy.
    Log.fatal(
      "Failed loading proxy into {}.{}, could not find setter function. Did you declare the field with 'val' instead of 'var'?",
      trueProxyTarget.getSimpleName,
      target.getName
    )
    throw new LoaderException(
      String.format(
        "Failed loading proxy into %s.%s, could not find setter function. Did you declare the field with 'val' instead of 'var'?",
        trueProxyTarget.getSimpleName,
        target.getName
      )
    )
  }

  @Override
  override def setInternalProxies(
      mod: ModContainer,
      side: Side,
      loader: ClassLoader
  ): Unit = {
    // For Scala mods, we want to enable authors to write them like so:
    // object ModName {
    //   @SidedProxy(...)
    //   var proxy: ModProxy = null
    // }
    // For this to work, we have to search inside the inner class Scala
    // generates for singletons, which is in called ModName$. These are
    // not automatically handled, because the mod discovery code ignores
    // internal classes.
    // Note that it is alternatively possible to write this like so:
    // class ModName {
    //   @SidedProxy(...)
    //   var proxy: ModProxy = null
    // }
    // object ModName extends ModName { ... }
    // which will fall back to the normal injection code which calls
    // setProxy in turn.

    // Get the actual mod implementation, which will be the inner class
    // if we have a singleton.
    val proxyTarget = mod.getMod.getClass
    if (proxyTarget.getName.endsWith("$")) {
      // So we have a singleton class, check if there are targets.
      for (target <- proxyTarget.getDeclaredFields) {
        // This will not turn up anything if the alternative
        // approach was taken (manually declaring the class).
        // So we don't initialize the field twice.
        if (target.getAnnotation(classOf[SidedProxy]) != null) {
          val targetType: String =
            if (side.isClient)
              target.getAnnotation(classOf[SidedProxy]).clientSide
            else target.getAnnotation(classOf[SidedProxy]).serverSide

          try {
            val proxy = Class.forName(targetType, true, loader).newInstance

            if (!target.getType.isAssignableFrom(proxy.getClass)) {
              Log.fatal(
                "Attempted to load a proxy type {} into {}.{}, but the types don't match",
                targetType,
                proxyTarget.getSimpleName,
                target.getName
              )
              throw new LoaderException(
                String.format(
                  "Attempted to load a proxy type %s into %s.%s, but the types don't match",
                  targetType,
                  proxyTarget.getSimpleName,
                  target.getName
                )
              )
            }

            setProxy(target, proxyTarget, proxy)
          } catch {
            case e: Exception =>
              Log.error(
                "An error occurred trying to load a proxy into {}.{}",
                target.getName,
                e
              )
              throw new LoaderException(e)
          }
        }
      }
    } else {
      Log.trace("Mod does not appear to be a singleton.")
    }
  }
}
